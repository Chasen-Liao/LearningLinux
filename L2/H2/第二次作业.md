## 1. 文本处理命令（grep cut  sort wc diff cmp）和正则表达式

1. 显示/etc/locale.gen中以'zh'开头的行。


```python
grep -i '^zh' /etc/locale.gen
```

2. 显示/etc/passwd文件中**不**是'/bin/bash'结尾的行。


```python
grep -v '/bin/bash$' /bin/bash
```

3. 将/etc/group中的数字单独列出。


```python
grep -oE '[0-9]+' /etc/group
```

4. 列出netstat -ant命令结果中出现端口为22（:22）的行。


```python
netstat -ant | grep ':22 '
```

5. 配合cut命令查看/etc/passwd，只显示系统中的用户名、UID、GID。

提示：

passwd文件每行数据：

`root:x:0:0:root:/root:/bin/bash`

解释：

`用户名:密码:UID（用户ID）:GID（组ID）:描述:主目录:缺省Shell`


```python
cut -d: -f1,3,4 /etc/passwd
```

6. 利用wc命令，通过/etc/passwd文件计算系统中的用户总数。


```python
wc -l /etc/passwd | cut -d' ' -f1
```

7. 列出/etc/passwd中的root用户（UID=0的用户）。要显示出root用户的所在整行。


```python
grep '^[^:]*:[^:]*:0:' /etc/passwd
```

8. 根据UID的大小，降序排列/etc/passwd中行并显示。要显示整行数据。


```python
sort -t: -k3 -nr /etc/passwd
```

9. df命令可以查看各个挂载区的利用率，请按利用率（已用%）从大到小排列，并显示。


```python
df -h | sort -k5 -nr
```

10. last命令可以查看最近登录的主机ip，请按ip进行统计并显示。**\*选做**

提示：统计时可以采用uniq -c命令

```
uniq命令读取输入文件，并进行比较，第二个及以后更多个重复行将被删去。

-c参数：输出时，在每行行首加上该行在文件中出现的次数。
```


```python
last | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | sort | uniq -c | sort -k1 -nr
```

11. 统计字母出现次数。**\*选做**

英文诗：

```
The seasons
Spring is gay with flower and song
Summmer is hot and days are long
Autumn is rich with fruit and grain
Winter brings snow and the New Year again
```

将上面英文诗写入文件seasons.txt中，然后计算每个字母出现的次数，大小写不区分。

提示：统计时可以采用uniq -c命令


```python
$ cat seasons.txt | tr ':upper:' ':lower:' | grep -o '[a-z]' | sort | uniq -c | sort -nr
     14 n
     12 i
     12 a
     10 s
     10 r
      9 e
      7 t
      7 g
      6 w
      6 o
      6 l
      6 h
      5 d
      4 m
      2 y
      2 f
      1 c
      1 b
```

12. 读取上面seasons.txt文件，寻找大写S开头的行。


```python
grep 'S' season.txt
```

13. 读取上面seasons.txt文件，寻找a开头（不区分大小写）的单词。


```python

```

14. 读取上面seasons.txt文件，寻找f或者s开头（不区分大小写）的单词。


```python
grep -oi '\ba[a-z]*\b' seasons.txt
```

15. 文件data.txt中数据：**\*选做**

```
叶湘伦 13888888888 330301200109090017 yxl@test.com 2023-08-08 5000.45
路小雨 18966666666 220101200210110023 lxy@test.com 2023-08-09 4800.88
```

[data.txt](assets/data.txt)

请匹配文本中的电话号码、身份证号码、邮箱、日期。


```python
grep -Eo '1[0-9]{10}' data.txt
# 解释：1[0-9]{10} 匹配1开头后面跟10位数字的电话号码
# 身份证号码匹配：18位数字，或以X结尾
grep -Eo '[0-9]{17}[0-9X]' data.txt
# 解释：[0-9]{17} 匹配17位数字，[0-9X] 匹配数字或X
# 邮箱匹配：包含@和.的字符串
grep -Eo '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' data.txt
# 解释：匹配标准邮箱格式，包含用户名@域名.后缀
# 日期匹配：YYYY-MM-DD格式
grep -Eo '[0-9]{4}-[0-9]{2}-[0-9]{2}' data.txt
```

## 2. 问答题

### 2.1. 下图为Linux系统目录树结构的一部分。

![](assets/作业2题目2配图.png)

1. 用户gdufe与用户root的家目录在哪里？

gdufe的工作目录在/home/gdufe；root的工作目录在/root


答：

在Linux系统中，普通用户的家目录通常在/home/用户名下，root在/root


2. 若当前工作目录是/home/gdufe，请给出目录mike、usr的相对路径与绝对路径。

若当前工作目录是/home/gdufe，mike的相对路径为../mike，绝对路径为/home/mike，usr的相对路径为../../usr，绝对路径为/usr。

答：

相对路径是相对于当前目录的路径，../表示上一级目录；绝对路径是从根目录开始的完整路径

## 3. 编程题

### 3.1. 汉诺塔（Tower of Hanoi），是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。请用C语言采用解决汉诺塔问题。

三根柱子分别用'A'，'B'，'C'表示。

输入：盘子数。

输出：移动步骤。

例如：
输入：3
输出：
A->C
A->B
C->B
A->C
B->A
B->C
A->C


```c
#include <stdio.h>

// 汉诺塔递归函数
void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        printf("%c->%c\n", from, to); // 只有一个盘子时直接移动
        return;
    }
    hanoi(n - 1, from, aux, to); // 将n-1个盘子从起始柱移动到辅助柱
    printf("%c->%c\n", from, to); // 将最大的盘子从起始柱移动到目标柱
    hanoi(n - 1, aux, to, from); // 将n-1个盘子从辅助柱移动到目标柱
}

int main() {
    int n;
    scanf("%d", &n); // 输入盘子数量
    hanoi(n, 'A', 'C', 'B'); // 调用汉诺塔函数，A是起始柱，C是目标柱，B是辅助柱
    return 0;
}

```

### 3.2. 用C语言输出n以内的素数。速度越快越好。

输入：

n

输出：

依次输入n以内的素数。


```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int main() {
    int n;
    scanf("%d", &n); // 输入n
    
    if (n < 2) {
        return 0; // 小于2没有素数
    }
    
    // 创建筛子数组，isPrime[i]为true表示i是素数
    bool *isPrime = (bool *)malloc((n + 1) * sizeof(bool));
    
    // 初始化筛子，假设所有数都是素数
    for (int i = 0; i <= n; i++) {
        isPrime[i] = true;
    }
    
    isPrime[0] = false; // 0不是素数
    isPrime[1] = false; // 1不是素数
    
    // 埃氏筛算法核心
    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            // 将i的所有倍数标记为非素数
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    // 输出所有素数
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            printf("%d ", i);
        }
    }
    printf("\n");
    
    free(isPrime); // 释放内存
    return 0;
}

```

### 3.3. 编程程序，功能：删去一维数组中重复数，只保留一个，最后再输出。

用宏定义定义数组大小。

#define  N  20

输入格式

一维数组。

输出格式

去重之后的数组。

输入输出样例

输入

2 2 2 3 4 4 5 6 6 6 6 7 7 8 9 9 10 10 10 10

输出

2 3 4 5 6 7 8 9 10

用一个新的数组来检查元素是否存在

```c
#include <stdio.h>
#define N 20 // 定义数组大小

int main() {
    int arr[N], result[N]; // 原始数组和结果数组
    int count = 0; // 结果数组中的元素计数
    
    // 输入数组
    for (int i = 0; i < N; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 去重处理
    for (int i = 0; i < N; i++) {
        int j;
        // 检查当前元素是否已经在结果数组中
        for (j = 0; j < count; j++) {
            if (result[j] == arr[i]) break;
        }
        // 如果不在结果数组中，则添加
        if (j == count) {
            result[count++] = arr[i];
        }
    }
    
    // 输出去重后的结果
    for (int i = 0; i < count; i++) {
        printf("%d ", result[i]);
    }
    printf("\n");
    
    return 0;
}

```
