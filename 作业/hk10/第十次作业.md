## 1. 问答题

### 1.1. 操作系统中进程通信的作用？

- 数据交换：在进程间传递信息或数据（例如父子进程交换计算结果或命令）。
- 同步与协调：通过通信机制实现进程间的同步（比如等待/通知、互斥），避免竞态条件。
- 资源共享：多个进程协同访问或共享资源（如共享内存、文件映射），提高效率。
- 分布式/模块化设计支持：把功能拆成多个进程（或服务），通过 IPC 协作完成复杂任务，便于隔离与安全控制。
- 提高可靠性与可扩展性：进程隔离错误域，单个进程崩溃不必影响全部，通过通信重启或替换组件。

### 1.2. Linux进程间通信有哪几种方式？这几种方式之间的特点是什么？

- 无名管道（pipe）：
  - 特点：半双工（单向）、只能用于具有亲缘关系的进程（父子或已创建的子进程之间）。
  - 适用：简单的父子通信、单向数据流传输。
- 有名管道（FIFO）：
  - 特点：存在于文件系统，可以在任意进程间通信（只要知道路径）、仍为字节流。
  - 适用：不同进程、不同会话之间的简单通信与脚本交互。

### 1.3. 查看以下代码：

```c
int fd1, fd2, fd3, fd4;
fd1 = open("a.txt", O_RDONLY);
fd2 = open("b.txt", O_WRONLY);
fd3 = dup(fd1);
fd4 = dup2(fd2, 0);
```

假设当前终端没有打开任何正常文件，请问：最后fd1、fd2、fd3和fd4的值为多少？并解释原因。

因为没有正常打开文件，open会返回一个最小的文件描述符，第一次fd1就被分配了最小的0，fd2因为0已经被分配，所以当前最小的就是1，以此类推。
最终结果如表：

| 变量      | 值     | 原因                               |
| ------- | ----- | -------------------------------- |
| **fd1** | **0** | 打开第一个文件得到最小 fd                   |
| **fd2** | **1** | 下一个最小可用 fd                       |
| **fd3** | **2** | dup(0) 返回最小未占用 fd                |
| **fd4** | **0** | dup2(1,0) 强制把 fd0 重定向到 fd2 指向的文件 |


提示：
- 系统调用dup()和dup2()都能够复制文件描述符。
- dup返回新的文件描述符，成功时返回最小的尚未被使用的文件描述符。
- dup2可以让用户指定返回的文件描述符的值，它通常用来重新打开或者重定向一个文件描述符。


## 2. 编程题

### 2.1. 利用dup/dup2实现往文件中写入数据。要求：在代码中执行两次以下语句：

`printf(“Hello Linux\n”);`

前一次输出到文件c.txt中，后一次输出到屏幕上。

```c
// 2-1.c dup/dup2 向文件中写入数据
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd, saved_stdout;

    // 1. 打开文件 c.txt，用于写入（不存在则创建）
    fd = open("c.txt", O_WRONLY | O_CREAT | O_TRUNC, 0664);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    // 2. 保存当前的标准输出文件描述符（屏幕）
    saved_stdout = dup(STDOUT_FILENO);
    if (saved_stdout < 0) {
        perror("dup");
        return 1;
    }

    // 3. 用 dup2 将文件描述符 fd 覆盖到标准输出 stdout
    if (dup2(fd, STDOUT_FILENO) < 0) {
        perror("dup2");
        return 1;
    }

    // 4. 此时 printf 输出会写入 c.txt
    printf("Hello Linux\n");
    fflush(NULL);    // 刷新所有标准 IO 缓冲

    // 5. 关闭文件 c.txt
    close(fd);

    // 6. 恢复标准输出到屏幕
    if (dup2(saved_stdout, STDOUT_FILENO) < 0) {
        perror("dup2 restore");
        return 1;
    }

    close(saved_stdout);

    // 7. 再次打印，此时输出到屏幕
    printf("Hello Linux\n");
    fflush(NULL);

    return 0;
}
```

![2-1](2-1.png)

提示：printf语句后增加fflush(NULL);语句，刷新打开的流。

### 2.2. 编写程序实现如下功能：创建父子进程，父子进程之间通过管道进行通信，父程向子进程发送英文字符串，子进程接收到该字符串后，将该字符串倒序，并附加上自己的进程pid传回给父进程。

例如：父进程发出Hello World!；子进程处理返回!dlroW olleH2709，2709是子进程号。

### 2.3. 利用无名管道pipe()函数、创建进程fork()函数，实现ps -uax | grep root |wc -l命令。

### 2.4. 用popen实现无名管道，完成ps -uax|grep root。

### 2.5. 有两个进程A和B，进程A读取a.txt的内容，通过命名管道发送给第二个进程B并输出显示。

### 2.6. 有两个进程A、B，进程A和B都定义了下列变量，进程A对变量进行赋值，要求将变量的值传递给进程B并输出显示。

```c
int a=1；
float b=2.2；
double c=3.1415926；
int ar[5]={10,20,30,40.50};
```

1. 采用命名管道传输数据，写出程序代码。
1. 采用共享内存传递数据，写出程序代码。


### 2.7. 有两个程序msgsendstruct.c和msgrecvstruct.c，前者将结构体数据类型：

```c
struct STU {
    char name[10];
    int age;f
    loat height;
}
```

的一个实例`stu={"张三", 20, 1.79}`发送给后者并输出显示。

1. 采用命名管道传输数据，写出程序代码。
1. 采用共享内存传递数据，写出程序代码。

### 2.8. 编写两个程序msgsend.c和msgrecv.c，msgsend进程不断从键盘读入信息，传送给进程msgrecv显示出来，写出程序代码。

1. 采用命名管道传输数据，写出程序代码。
1. 采用共享内存传递数据，写出程序代码。

### 2.9. 采用有名信号量实现以下功能：两个独立进程交替向文件中写入数据，要求A进程向文件number.txt中写入1000以下的奇数，B进程向文件中写入1000以下的偶数（含1000），交替写，因此文件number.txt中内容应该为“1234567891011121314151617181920……”。

### 2.10. 有一个间谍，他与接头人之间依赖通风信进行沟通。需要沟通时，间谍就往一个约定地点的石头下面放通风信，接头人后去取信，当间谍放在石头下的信没有被取走，间谍就不能再放信。请采用有名信号量实现上述模型。

提示思路：
1. 两个进程，分别是间谍进程、接头人进程；
1. 每个进程执行时有一个参数，就是信件内容，建议增加发出时间
1. 采用两个有名信号量，一个表示间谍占用石头放信；一个表示接头人占用石头取信。

### 2.11. 有一只铁笼子，每次只能放入一只动物，猎手向笼子里放入老虎，农民向笼子里放入猪；动物园等待取笼子里的老虎，饭店等待取笼子里的猪。下面代码实现上述模型，请将空白处填满运行。


### 2.12. 采用无名信号量实现以下功能：三个进程（父子进程）交替向文件中写入一个字节的数据，要求A进程向文件a.txt中写入“ABCDEFGHIJ”，B进程向文件中写入“==========”，C进程向文件写入“0123456789”因此文件a.txt中内容应该为“A=0B=1C=2D=3E=4F=5G=6H=7I=8J=9”。
